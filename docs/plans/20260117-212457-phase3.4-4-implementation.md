# 実装計画: Phase 3.4 プロンプトテンプレート & Phase 4 LangGraphノード

**作成日**: 2026-01-17 21:24
**前提**: Phase 3.3 完了（tools/search.py, tools/scrape.py 実装済み）

---

## 概要

本計画では以下を実装する:
- **Phase 3.4**: プロンプトテンプレートの改善と関数化
- **Phase 4**: 全5ノードの TDD 実装

---

## Phase 3.4: プロンプトテンプレート

### 3.4.1 現状分析

現在の `src/prompts/templates.py`:
```python
PLANNER_PROMPT = """..."""      # {task} を使用
SUMMARIZER_PROMPT = """..."""   # {content} を使用
REVIEWER_PROMPT = """..."""     # {task}, {content} を使用
WRITER_PROMPT = """..."""       # {task}, {content}, {references} を使用
```

### 3.4.2 改善目標

1. **型安全なフォーマット関数**: 各テンプレートに対応するフォーマット関数を提供
2. **JSON出力の強制**: Plannerプロンプトで確実にJSON形式を出力させる
3. **構造化判定**: Reviewerプロンプトで "yes"/"no" を確実に抽出できる形式
4. **テスト可能性**: 各関数が正しいプレースホルダーを持つことをテスト

### 3.4.3 実装仕様

#### 新規追加する関数

```python
def format_planner_prompt(task: str) -> str:
    """Planner用プロンプトを生成する。"""

def format_summarizer_prompt(content: str, max_length: int = 500) -> str:
    """Summarizer用プロンプトを生成する。"""

def format_reviewer_prompt(task: str, content: list[str]) -> str:
    """Reviewer用プロンプトを生成する。"""

def format_writer_prompt(task: str, content: list[str], references: list[str]) -> str:
    """Writer用プロンプトを生成する。"""
```

#### プロンプト改善

**PLANNER_PROMPT** (JSON出力強制):
```
You are a research planner...

IMPORTANT: Your response must be ONLY a valid JSON object, no other text.
The JSON must have this exact format:
{"queries": ["query1", "query2", ...]}

User Query: {task}
```

**REVIEWER_PROMPT** (構造化判定):
```
...
Respond with a JSON object:
{"sufficient": true/false, "reason": "explanation"}
```

### 3.4.4 TDD テストケース

| テスト名 | 内容 |
|---------|------|
| `test_planner_prompt_contains_task_placeholder` | `{task}` が含まれる |
| `test_planner_prompt_requests_json` | "JSON" の指示が含まれる |
| `test_format_planner_prompt_substitutes_task` | task変数が正しく展開される |
| `test_format_planner_prompt_empty_task_raises` | 空文字列でValueError |
| `test_summarizer_prompt_contains_content_placeholder` | `{content}` が含まれる |
| `test_format_summarizer_prompt_with_max_length` | max_length指示が含まれる |
| `test_reviewer_prompt_contains_both_placeholders` | `{task}`, `{content}` |
| `test_format_reviewer_prompt_joins_content_list` | リストが改行で結合される |
| `test_writer_prompt_contains_all_placeholders` | 全3つのプレースホルダー |
| `test_format_writer_prompt_formats_references` | 参照がMarkdownリンク形式 |

### 3.4.5 ファイル構成

```
tests/
└── test_prompts.py          # 新規作成（10テスト）

src/prompts/
└── templates.py             # 既存ファイルを拡張
```

---

## Phase 4: LangGraphノード実装

### 4.0 共通設計

#### ノード関数シグネチャ

全ノードは以下の形式に従う:
```python
async def xxx_node(state: ResearchState) -> dict[str, Any]:
    """ノードの処理を行い、状態更新を返す。"""
```

#### LLM呼び出しの抽象化

各ノードで共通して使用するLLM呼び出しを抽象化:

```python
# src/llm.py（新規作成）
from langchain_ollama import ChatOllama

async def call_llm(
    prompt: str,
    model: str,
    temperature: float = 0.7,
) -> str:
    """Ollama LLMを呼び出してテキストを返す。"""
```

### 4.1 Plannerノード (`nodes/planner.py`)

#### 責務
- ユーザーの質問を受け取り、検索クエリのリストを生成
- DeepSeek R1モデル（Planner用）を使用

#### 入出力

| 入力 (state) | 出力 (dict) |
|-------------|-------------|
| `task: str` | `plan: list[str]` |

#### 実装フロー

```
1. state["task"] を取得
2. format_planner_prompt(task) でプロンプト生成
3. call_llm() で DeepSeek R1 を呼び出し
4. JSON レスポンスをパース
5. パース失敗時はリトライ（最大3回）
6. {"plan": queries} を返す
```

#### エラーハンドリング

| 状況 | 対応 |
|-----|------|
| JSONパース失敗 | リトライ（最大3回） |
| 空のクエリリスト | 元のtaskをそのままクエリとして使用 |
| LLM呼び出し失敗 | PlannerError を発生 |

#### TDD テストケース（8件）

| テスト名 | 内容 |
|---------|------|
| `test_planner_returns_plan_list` | 正常系: plan リストを返す |
| `test_planner_parses_json_response` | JSON形式のレスポンスをパース |
| `test_planner_retries_on_invalid_json` | 無効なJSONでリトライ |
| `test_planner_max_retries_exceeded` | 3回失敗で PlannerError |
| `test_planner_uses_task_as_fallback` | 空クエリ時のフォールバック |
| `test_planner_calls_correct_model` | planner_model を使用 |
| `test_planner_handles_llm_error` | LLMエラー時の例外処理 |
| `test_planner_empty_task_raises` | 空タスクでValueError |

---

### 4.2 Researcherノード (`nodes/researcher.py`)

#### 責務
- 検索クエリを SearXNG で実行
- 検索結果のURLリストを収集

#### 入出力

| 入力 (state) | 出力 (dict) |
|-------------|-------------|
| `plan: list[str]` | `current_search_query: str` |
| `steps_completed: int` | `references: list[str]` (追加) |
| | `steps_completed: int` (更新) |

#### 実装フロー

```
1. plan[steps_completed] から現在のクエリを取得
2. search_searxng(query) で検索実行
3. 検索結果からURLを抽出（上位5件）
4. {
     "current_search_query": query,
     "references": urls,
     "steps_completed": steps_completed + 1
   } を返す
```

#### TDD テストケース（7件）

| テスト名 | 内容 |
|---------|------|
| `test_researcher_executes_current_query` | 正しいクエリで検索 |
| `test_researcher_extracts_urls` | URLリストを抽出 |
| `test_researcher_limits_results` | 上位5件に制限 |
| `test_researcher_increments_steps` | steps_completed +1 |
| `test_researcher_handles_empty_results` | 結果0件でも継続 |
| `test_researcher_handles_search_error` | SearchError時のフォールバック |
| `test_researcher_skips_duplicate_urls` | 重複URLを除外 |

---

### 4.3 Scraperノード (`nodes/scraper.py`)

#### 責務
- URLからコンテンツを取得
- コンテンツを即時要約してメモリ節約

#### 入出力

| 入力 (state) | 出力 (dict) |
|-------------|-------------|
| `references: list[str]` | `content: list[str]` (追加) |
| `current_search_query: str` | |

#### 実装フロー

```
1. 最新の references（直近の検索で追加されたURL）を取得
2. scrape_multiple(urls) でコンテンツ取得
3. 各コンテンツに対して:
   a. format_summarizer_prompt(content) でプロンプト生成
   b. call_llm(worker_model) で要約
4. {"content": summaries} を返す
```

#### TDD テストケース（8件）

| テスト名 | 内容 |
|---------|------|
| `test_scraper_fetches_urls` | URLからコンテンツ取得 |
| `test_scraper_summarizes_content` | 各コンテンツを要約 |
| `test_scraper_uses_worker_model` | worker_model を使用 |
| `test_scraper_handles_scrape_failure` | スクレイプ失敗時はスキップ |
| `test_scraper_truncates_long_content` | 長文を切り詰めてから要約 |
| `test_scraper_returns_content_list` | content リストを返す |
| `test_scraper_handles_empty_urls` | URL 0件でも継続 |
| `test_scraper_includes_source_in_summary` | 要約にソースURL付記 |

---

### 4.4 Reviewerノード (`nodes/reviewer.py`)

#### 責務
- 収集した情報が質問に答えるのに十分かを判定
- 不十分なら Researcher へ戻る、十分なら Writer へ進む

#### 入出力

| 入力 (state) | 出力 (dict) |
|-------------|-------------|
| `task: str` | `is_sufficient: bool` |
| `content: list[str]` | |
| `steps_completed: int` | |

#### 実装フロー

```
1. format_reviewer_prompt(task, content) でプロンプト生成
2. call_llm(worker_model) で判定
3. JSONレスポンスから sufficient を抽出
4. steps_completed >= max_iterations なら強制的に sufficient=True
5. {"is_sufficient": sufficient} を返す
```

#### 条件付きエッジ用関数

```python
def should_continue_research(state: ResearchState) -> str:
    """Reviewerの判定に基づいてルーティングを決定。"""
    if state["is_sufficient"]:
        return "writer"
    return "researcher"
```

#### TDD テストケース（8件）

| テスト名 | 内容 |
|---------|------|
| `test_reviewer_returns_is_sufficient` | is_sufficient を返す |
| `test_reviewer_sufficient_true` | 十分な情報で True |
| `test_reviewer_sufficient_false` | 不十分な情報で False |
| `test_reviewer_max_iterations_forces_true` | 最大反復で強制 True |
| `test_reviewer_parses_json_response` | JSONレスポンスをパース |
| `test_reviewer_handles_invalid_json` | 無効JSONでデフォルト False |
| `test_should_continue_returns_writer` | sufficient=True で "writer" |
| `test_should_continue_returns_researcher` | sufficient=False で "researcher" |

---

### 4.5 Writerノード (`nodes/writer.py`)

#### 責務
- 収集した全情報を統合
- 最終レポートを生成（Markdown形式）

#### 入出力

| 入力 (state) | 出力 (dict) |
|-------------|-------------|
| `task: str` | `report: str` |
| `content: list[str]` | |
| `references: list[str]` | |

#### 実装フロー

```
1. format_writer_prompt(task, content, references) でプロンプト生成
2. call_llm(planner_model) で最終レポート生成（高品質モデル使用）
3. {"report": report} を返す
```

#### TDD テストケース（6件）

| テスト名 | 内容 |
|---------|------|
| `test_writer_returns_report` | report 文字列を返す |
| `test_writer_uses_planner_model` | planner_model を使用 |
| `test_writer_includes_all_content` | 全contentを含む |
| `test_writer_formats_references` | 参照をMarkdown形式 |
| `test_writer_handles_empty_content` | content 0件でも動作 |
| `test_writer_handles_llm_error` | LLMエラー時の例外 |

---

## 新規作成ファイル

### src/llm.py

LLM呼び出しの共通ユーティリティ:

```python
"""LLM utilities for Ollama integration."""

from langchain_ollama import ChatOllama
from src.config import settings

class LLMError(Exception):
    """LLM呼び出し時のエラー。"""

async def call_llm(
    prompt: str,
    model: str | None = None,
    temperature: float = 0.7,
) -> str:
    """Ollama LLMを呼び出す。"""
```

#### TDD テストケース（5件）

| テスト名 | 内容 |
|---------|------|
| `test_call_llm_returns_string` | 文字列を返す |
| `test_call_llm_uses_specified_model` | 指定モデルを使用 |
| `test_call_llm_default_model` | デフォルトで worker_model |
| `test_call_llm_handles_timeout` | タイムアウトで LLMError |
| `test_call_llm_handles_connection_error` | 接続エラーで LLMError |

---

## 依存関係図

```
prompts/templates.py  ─────┐
                           ├──> nodes/planner.py
config.py ─────────────────┤
                           ├──> nodes/researcher.py ──> tools/search.py
llm.py (新規) ─────────────┤
                           ├──> nodes/scraper.py ────> tools/scrape.py
                           │
                           ├──> nodes/reviewer.py
                           │
                           └──> nodes/writer.py
```

---

## 実装順序

| ステップ | 内容 | 依存 |
|---------|------|------|
| 1 | `tests/test_prompts.py` 作成 (Red) | なし |
| 2 | `src/prompts/templates.py` 拡張 (Green) | なし |
| 3 | `tests/test_llm.py` 作成 (Red) | なし |
| 4 | `src/llm.py` 作成 (Green) | config.py |
| 5 | `tests/nodes/test_planner.py` 作成 (Red) | なし |
| 6 | `src/nodes/planner.py` 実装 (Green) | llm.py, templates.py |
| 7 | `tests/nodes/test_researcher.py` 作成 (Red) | なし |
| 8 | `src/nodes/researcher.py` 実装 (Green) | tools/search.py |
| 9 | `tests/nodes/test_scraper.py` 作成 (Red) | なし |
| 10 | `src/nodes/scraper.py` 実装 (Green) | llm.py, tools/scrape.py |
| 11 | `tests/nodes/test_reviewer.py` 作成 (Red) | なし |
| 12 | `src/nodes/reviewer.py` 実装 (Green) | llm.py, templates.py |
| 13 | `tests/nodes/test_writer.py` 作成 (Red) | なし |
| 14 | `src/nodes/writer.py` 実装 (Green) | llm.py, templates.py |
| 15 | Refactor: 全体の ruff check/format | 全ノード |

---

## テスト総数見込み

| モジュール | テスト数 |
|-----------|---------|
| prompts/templates.py | 10 |
| llm.py | 5 |
| nodes/planner.py | 8 |
| nodes/researcher.py | 7 |
| nodes/scraper.py | 8 |
| nodes/reviewer.py | 8 |
| nodes/writer.py | 6 |
| main.py (デモモード) | 4 |
| **合計** | **56** |

既存テスト (46) + 新規 (56) = **102テスト**

---

## 品質目標

- pytest: 全テストパス
- coverage: 85%以上（ノード全体）
- mypy: エラーなし
- ruff: リント/フォーマット通過

---

## デモモード（動作確認用）

各フェーズ完了時に部品の動作確認ができるよう、`main.py` にデモモードを実装する。

### 使用方法

```bash
# Phase 3 完了後に使用可能
uv run python -m src.main --demo search "Python programming"
uv run python -m src.main --demo scrape "https://example.com"

# Phase 4 完了後に使用可能
uv run python -m src.main --demo plan "量子コンピュータとは何か"
uv run python -m src.main --demo summarize "長いテキスト..."
```

### デモモード一覧

| モード | 利用可能時期 | 動作 | 確認できること |
|--------|-------------|------|---------------|
| `search` | Phase 3完了後 | SearXNG検索を実行 | 検索結果のタイトル・URL一覧 |
| `scrape` | Phase 3完了後 | 指定URLをスクレイプ | Markdown変換結果 |
| `plan` | Phase 4完了後 | Plannerノードを実行 | LLMが生成した検索クエリ一覧 |
| `summarize` | Phase 4完了後 | テキストを要約 | LLM要約結果 |

### 実装仕様

```python
# src/main.py

import argparse
import asyncio

async def demo_search(query: str) -> None:
    """検索ツールのデモ。"""
    from src.tools.search import search_searxng
    results = await search_searxng(query, num_results=5)
    for r in results:
        print(f"- {r.title}")
        print(f"  {r.url}")
        if r.snippet:
            print(f"  {r.snippet[:100]}...")
        print()

async def demo_scrape(url: str) -> None:
    """スクレイピングツールのデモ。"""
    from src.tools.scrape import scrape_url
    result = await scrape_url(url)
    if result.success:
        print(f"URL: {result.url}")
        print(f"Length: {len(result.markdown)} chars")
        print("-" * 40)
        print(result.markdown[:1000])
        if len(result.markdown) > 1000:
            print("\n... [truncated]")
    else:
        print(f"Failed: {result.error}")

async def demo_plan(task: str) -> None:
    """Plannerノードのデモ。"""
    from src.nodes.planner import planner_node
    state = {"task": task}
    result = await planner_node(state)
    print("Generated search queries:")
    for i, q in enumerate(result["plan"], 1):
        print(f"  {i}. {q}")

async def demo_summarize(text: str) -> None:
    """要約のデモ。"""
    from src.llm import call_llm
    from src.prompts.templates import format_summarizer_prompt
    prompt = format_summarizer_prompt(text)
    summary = await call_llm(prompt)
    print("Summary:")
    print(summary)

def main() -> None:
    parser = argparse.ArgumentParser(description="Local Deep Research")
    parser.add_argument("--demo", choices=["search", "scrape", "plan", "summarize"])
    parser.add_argument("input", nargs="?", help="Query, URL, or text")
    args = parser.parse_args()

    if args.demo:
        if not args.input:
            print(f"Error: --demo {args.demo} requires input")
            return
        demo_funcs = {
            "search": demo_search,
            "scrape": demo_scrape,
            "plan": demo_plan,
            "summarize": demo_summarize,
        }
        asyncio.run(demo_funcs[args.demo](args.input))
    else:
        # 完全なリサーチ実行（Phase 5で実装）
        raise NotImplementedError("Full research not yet implemented")

if __name__ == "__main__":
    main()
```

### TDD テストケース（4件追加）

| テスト名 | 内容 |
|---------|------|
| `test_demo_search_prints_results` | 検索結果を出力 |
| `test_demo_scrape_prints_markdown` | Markdownを出力 |
| `test_demo_requires_input` | 入力なしでエラー |
| `test_demo_invalid_mode` | 無効モードでエラー |

### 実装タイミング

- **Phase 3.4 完了後**: `demo_search`, `demo_scrape` を実装
- **Phase 4 完了後**: `demo_plan`, `demo_summarize` を追加

---

## 次フェーズへの準備

Phase 4 完了後、Phase 5（グラフ構築）に進む:
- `src/graph.py` の実装
- 条件付きエッジの設定（`should_continue_research`）
- `src/main.py` の CLI 実装（デモモードを拡張）
